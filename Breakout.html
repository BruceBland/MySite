<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arcade Breakout</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800&amp;display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --bg-a: #06121f;
      --bg-b: #10334d;
      --panel: #f5f4e8;
      --ink: #1f2e3d;
      --accent: #e65100;
      --accent-soft: #ffb56b;
      --line: #d9d3bf;
      --good: #0f7b2f;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      min-height: 100%;
      font-family: "Outfit", "SF Pro Text", "Helvetica Neue", "Segoe UI", sans-serif;
      color: #fff;
      background-image:
        linear-gradient(180deg, rgba(245, 247, 250, 0.72) 0%, rgba(238, 243, 255, 0.78) 100%),
        radial-gradient(1200px 700px at 12% -20%, rgba(219, 231, 255, 0.5) 0%, transparent 66%),
        radial-gradient(1100px 620px at 95% 12%, rgba(216, 245, 255, 0.46) 0%, transparent 64%),
        url("BackgroundImage.jpeg");
      background-size: auto, auto, auto, cover;
      background-position: center, center, center, center;
      background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
      background-attachment: scroll, scroll, scroll, fixed;
    }

    body {
      display: grid;
      place-items: center;
      padding: 4.8rem 1rem 1rem;
      animation: scene-in 500ms ease-out;
      position: relative;
      overflow-x: hidden;
    }

    .app {
      width: min(926px, 100%);
      position: relative;
      z-index: 1;
    }

    .bg-glow {
      position: fixed;
      width: 32rem;
      height: 32rem;
      border-radius: 999px;
      filter: blur(56px);
      pointer-events: none;
      z-index: 0;
    }

    .bg-glow-1 {
      top: -14rem;
      left: -10rem;
      background: rgba(16, 102, 255, 0.22);
    }

    .bg-glow-2 {
      bottom: -16rem;
      right: -12rem;
      background: rgba(0, 166, 166, 0.2);
    }

    .home-link-fixed {
      position: fixed;
      top: 14px;
      left: 14px;
      z-index: 10;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.64rem 1rem;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.92rem;
      color: #0f172a;
      background: rgba(255, 255, 255, 0.86);
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.18);
      backdrop-filter: blur(10px);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .home-link-fixed:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.22);
    }

    .title {
      margin: 0 0 0.85rem;
      font-family: "Impact", "Haettenschweiler", "Arial Narrow Bold", sans-serif;
      letter-spacing: 0.08em;
      font-size: clamp(1.4rem, 3vw, 2rem);
      text-align: center;
      text-transform: uppercase;
      color: #000;
      text-shadow: none;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(240px, 1fr) 230px;
      gap: 1rem;
      align-items: stretch;
    }

    .game-column {
      display: grid;
      gap: 0.6rem;
      align-content: start;
    }

    .game-shell {
      position: relative;
      background: #050b11;
      border: 4px solid #000;
      border-radius: 12px;
      overflow: hidden;
      box-shadow:
        0 16px 36px rgba(0, 0, 0, 0.42),
        inset 0 0 22px rgba(255, 255, 255, 0.08);
      animation: pop-in 420ms ease-out;
    }

    .game-shell::after {
      content: "";
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.02) 0px,
        rgba(255, 255, 255, 0.02) 1px,
        transparent 2px,
        transparent 4px
      );
      pointer-events: none;
      mix-blend-mode: screen;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 35 / 18;
      touch-action: none;
      background: radial-gradient(circle at top, #153045, #050b11 65%);
    }

    .panel {
      background: var(--panel);
      color: var(--ink);
      border: 3px solid #000;
      border-radius: 12px;
      padding: 0.72rem;
      display: grid;
      gap: 0.6rem;
      align-content: start;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.32);
      animation: slide-in 420ms ease-out;
      font-size: 0.86rem;
    }

    .panel h2 {
      margin: 0;
      font-size: 0.86rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #2d4358;
    }

    .bb-logo {
      margin: 0 0 0.25rem;
      border: 2px solid #000;
      border-radius: 10px;
      padding: 0.55rem 0.6rem;
      background: linear-gradient(160deg, #1a2a3d 0%, #0f1824 100%);
      text-align: center;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
    }

    .bb-logo .brand {
      display: block;
      font-size: 1rem;
      font-weight: 800;
      letter-spacing: 0.08em;
      line-height: 1;
      color: #e9f3ff;
    }

    .bb-logo .sub {
      display: block;
      margin-top: 0.25rem;
      font-size: 0.64rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #b9d4ef;
    }

    .card {
      border: 1px solid var(--line);
      border-radius: 9px;
      padding: 0.52rem;
      background: #fffdf7;
    }

    .stats {
      display: grid;
      gap: 0.4rem;
      font-weight: 700;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.84rem;
    }

    .stat-row strong {
      color: var(--accent);
      font-size: 0.95rem;
      min-width: 2.4ch;
      text-align: right;
    }

    .leaderboard {
      margin: 0;
      padding: 0 0 0 1.3rem;
      display: grid;
      gap: 0.34rem;
      min-height: 130px;
      max-height: 165px;
      overflow: auto;
      font-size: 0.8rem;
    }

    .leaderboard-card {
      background: linear-gradient(180deg, #101c27, #050b11);
      border-color: #000;
      color: #d9e6f2;
      box-shadow: inset 0 0 16px rgba(255, 255, 255, 0.04);
    }

    .leaderboard-card h2 {
      color: #ffe7bf;
    }

    .leaderboard-card .entry-name {
      color: #ffd7a0;
    }

    .leaderboard-card .entry-score {
      color: #f3f7ff;
    }

    .leaderboard-card .leaderboard li.empty {
      color: #8fa5bc;
    }

    .leaderboard li {
      display: flex;
      justify-content: space-between;
      gap: 0.3rem;
      padding-right: 0.2rem;
    }

    .leaderboard li.empty {
      list-style: none;
      margin-left: -1.3rem;
      color: #5e6f80;
      font-style: italic;
    }

    .entry-name {
      font-weight: 700;
      color: #2d4358;
    }

    .entry-score {
      font-variant-numeric: tabular-nums;
      color: #112335;
    }

    .leaderboard-form {
      display: grid;
      gap: 0.55rem;
    }

    .leaderboard-form label {
      display: block;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #2d4358;
    }

    .leaderboard-form input {
      width: 100%;
      border: 1px solid #c8b79a;
      border-radius: 8px;
      padding: 0.36rem 0.45rem;
      font-size: 0.88rem;
      text-transform: uppercase;
    }

    .leaderboard-form input:disabled {
      background: #f2ede2;
      color: #7a7a7a;
    }

    .row {
      display: flex;
      gap: 0.55rem;
      align-items: center;
    }

    button {
      border: none;
      border-radius: 8px;
      padding: 0.42rem 0.62rem;
      font-size: 0.8rem;
      background: linear-gradient(#f67c2b, #d45a12);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 120ms ease, opacity 120ms ease;
    }

    button:hover {
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
    }

    .hint {
      margin: 0;
      font-size: 0.74rem;
      color: #3f5163;
      min-height: 2.2em;
    }

    .board-controls {
      background: #050b11;
      border: 2px solid #000;
      border-radius: 10px;
      padding: 0.5rem 0.65rem;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.3);
    }

    .board-controls h2 {
      margin: 0 0 0.3rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #ffe7bf;
    }

    .hint.success {
      color: var(--good);
      font-weight: 700;
    }

    .controls {
      margin: 0;
      padding-left: 1.2rem;
      display: grid;
      gap: 0.3rem;
      color: #d9e6f2;
      font-size: 0.76rem;
    }

    @keyframes pop-in {
      from {
        transform: scale(0.98);
        opacity: 0.65;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes slide-in {
      from {
        transform: translateX(16px);
        opacity: 0.6;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes scene-in {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @media (max-width: 860px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .leaderboard {
        max-height: 150px;
      }
    }
  </style>
</head>
<body>
  <div class="bg-glow bg-glow-1" aria-hidden="true"></div>
  <div class="bg-glow bg-glow-2" aria-hidden="true"></div>
  <a class="home-link-fixed" href="games.html">Home</a>
  <main class="app">
    <h1 class="title">Arcade Breakout</h1>
    <section class="layout">
      <div class="game-column">
        <div class="game-shell">
          <canvas id="gameCanvas" width="740" height="380" aria-label="Breakout game area"></canvas>
        </div>
        <section class="board-controls">
          <h2>Controls</h2>
          <ul class="controls">
            <li>Move: Left/Right Arrow or A/D</li>
            <li>Launch: Space, click, or tap</li>
            <li>Pause: P</li>
            <li>Restart: Enter or New Game button</li>
          </ul>
          <div class="row">
            <button id="newGameBtn" type="button">New Game</button>
          </div>
        </section>
      </div>
      <aside class="panel">
        <div class="bb-logo" aria-label="BB Games logo">
          <span class="brand">BB GAMES</span>
          <span class="sub">Breakout Arcade</span>
        </div>
        <section class="card stats">
          <div class="stat-row"><span>Score</span><strong id="uiScore">0</strong></div>
          <div class="stat-row"><span>Lives</span><strong id="uiLives">3</strong></div>
          <div class="stat-row"><span>Level</span><strong id="uiLevel">1</strong></div>
        </section>

        <section class="card leaderboard-card">
          <h2>Leaderboard</h2>
          <ol class="leaderboard" id="leaderboard"></ol>
        </section>

        <section class="card">
          <h2>Submit Score</h2>
          <form class="leaderboard-form" id="leaderboardForm">
            <label for="initials">Initials (3 max)</label>
            <div class="row">
              <input id="initials" name="initials" maxlength="3" autocomplete="off" placeholder="AAA">
              <button type="submit" id="saveScoreBtn" disabled>Save</button>
            </div>
          </form>
          <p class="hint" id="saveHint">Finish a run to submit a score.</p>
        </section>

      </aside>
    </section>
  </main>

  <script>
    (() => {
      "use strict";

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      const uiScore = document.getElementById("uiScore");
      const uiLives = document.getElementById("uiLives");
      const uiLevel = document.getElementById("uiLevel");

      const leaderboardEl = document.getElementById("leaderboard");
      const formEl = document.getElementById("leaderboardForm");
      const initialsEl = document.getElementById("initials");
      const saveBtnEl = document.getElementById("saveScoreBtn");
      const saveHintEl = document.getElementById("saveHint");
      const newGameBtn = document.getElementById("newGameBtn");

      const STORAGE_KEY = "breakout_leaderboard_v1";

      const state = {
        score: 0,
        lives: 3,
        level: 1,
        paused: false,
        gameOver: false,
        canSubmitScore: false,
        hasSubmittedScore: false
      };

      const keys = { left: false, right: false };

      const paddle = {
        x: canvas.width / 2 - 65,
        y: canvas.height - 36,
        w: 130,
        h: 15,
        speed: 620
      };

      const ball = {
        x: canvas.width / 2,
        y: canvas.height - 52,
        r: 9,
        vx: 220,
        vy: -320,
        baseSpeed: 350,
        stuckToPaddle: true
      };

      const brickConfig = {
        cols: 12,
        rows: 6,
        topOffset: 56,
        sideOffset: 22,
        gap: 6,
        height: 18,
        palette: ["#ff3f34", "#ff6b2f", "#ffc62a", "#48db5f", "#1dd1a1", "#54a0ff"],
        points: [70, 60, 50, 40, 30, 20]
      };

      let bricks = [];
      let bricksLeft = 0;
      let leaderboard = loadLeaderboard();
      let lastFrameTime = performance.now();

      function loadLeaderboard() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return [];
          }
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return [];
          }
          return parsed
            .map((entry) => ({
              name: sanitizeInitials(entry.name || "AAA"),
              score: Number(entry.score) || 0,
              level: Number(entry.level) || 1
            }))
            .sort((a, b) => b.score - a.score || b.level - a.level)
            .slice(0, 10);
        } catch (_err) {
          return [];
        }
      }

      function persistLeaderboard() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(leaderboard));
      }

      function renderLeaderboard() {
        leaderboardEl.textContent = "";

        if (!leaderboard.length) {
          const li = document.createElement("li");
          li.className = "empty";
          li.textContent = "No scores yet.";
          leaderboardEl.appendChild(li);
          return;
        }

        leaderboard.forEach((entry) => {
          const li = document.createElement("li");

          const name = document.createElement("span");
          name.className = "entry-name";
          name.textContent = `${entry.name} (L${entry.level})`;

          const score = document.createElement("span");
          score.className = "entry-score";
          score.textContent = String(entry.score);

          li.appendChild(name);
          li.appendChild(score);
          leaderboardEl.appendChild(li);
        });
      }

      function sanitizeInitials(value, fallback = "AAA") {
        const cleaned = String(value || "")
          .toUpperCase()
          .replace(/[^A-Z0-9]/g, "")
          .slice(0, 3);
        return cleaned || fallback;
      }

      function getEnteredInitials() {
        return sanitizeInitials(initialsEl.value, "");
      }

      function setSaveState(enabled, message, success = false) {
        state.canSubmitScore = enabled && !state.hasSubmittedScore;
        initialsEl.disabled = false;
        saveBtnEl.disabled = !state.canSubmitScore;
        saveHintEl.textContent = message;
        saveHintEl.className = success ? "hint success" : "hint";

        if (state.canSubmitScore) {
          initialsEl.focus();
          initialsEl.select();
        }
      }

      function qualifiesForLeaderboard(score) {
        if (score <= 0) {
          return false;
        }
        if (leaderboard.length < 10) {
          return true;
        }
        return score > leaderboard[leaderboard.length - 1].score;
      }

      function buildBricks() {
        const desiredRows = Math.min(brickConfig.rows + (state.level - 1), 9);
        const minClearanceAbovePaddle = 72;
        const maxRowsThatFit = Math.max(
          brickConfig.rows,
          Math.floor(
            (paddle.y - minClearanceAbovePaddle - brickConfig.topOffset + brickConfig.gap) /
              (brickConfig.height + brickConfig.gap)
          )
        );
        const rows = Math.max(1, Math.min(desiredRows, maxRowsThatFit));
        const pointsTable = [...brickConfig.points];
        while (pointsTable.length < rows) {
          pointsTable.push(20);
        }

        bricks = [];
        const brickW =
          (canvas.width - brickConfig.sideOffset * 2 - (brickConfig.cols - 1) * brickConfig.gap) /
          brickConfig.cols;

        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < brickConfig.cols; col += 1) {
            bricks.push({
              x: brickConfig.sideOffset + col * (brickW + brickConfig.gap),
              y: brickConfig.topOffset + row * (brickConfig.height + brickConfig.gap),
              w: brickW,
              h: brickConfig.height,
              color: brickConfig.palette[row % brickConfig.palette.length],
              points: pointsTable[row],
              alive: true
            });
          }
        }
        bricksLeft = bricks.length;
      }

      function resetBall(stick) {
        ball.stuckToPaddle = stick;
        ball.x = paddle.x + paddle.w / 2;
        ball.y = paddle.y - ball.r - 1;

        const speed = Math.min(ball.baseSpeed + (state.level - 1) * 34, 760);
        const direction = Math.random() > 0.5 ? 1 : -1;
        ball.vx = direction * speed * 0.58;
        ball.vy = -Math.sqrt(speed * speed - ball.vx * ball.vx);
      }

      function startNewGame() {
        state.score = 0;
        state.lives = 3;
        state.level = 1;
        state.paused = false;
        state.gameOver = false;
        state.canSubmitScore = false;
        state.hasSubmittedScore = false;

        paddle.w = 130;
        paddle.x = canvas.width / 2 - paddle.w / 2;
        ball.baseSpeed = 350;

        buildBricks();
        resetBall(true);

        if (getEnteredInitials()) {
          setSaveState(false, "Press launch to start. Finish a run to submit a score.");
        } else {
          setSaveState(false, "Enter initials before starting.");
        }
        updateHud();
      }

      function nextLevel() {
        state.level += 1;
        paddle.w = Math.max(84, paddle.w - 6);
        buildBricks();
        resetBall(true);
        updateHud();
      }

      function loseLife() {
        state.lives -= 1;
        if (state.lives <= 0) {
          state.gameOver = true;
          if (qualifiesForLeaderboard(state.score)) {
            setSaveState(true, "Leaderboard run. Enter initials and save.");
          } else {
            setSaveState(false, "Game over. Score did not reach the top list.");
          }
        } else {
          resetBall(true);
        }
        updateHud();
      }

      function launchBall() {
        if (!state.gameOver && ball.stuckToPaddle) {
          if (!getEnteredInitials()) {
            setSaveState(false, "Enter initials before starting.");
            return;
          }
          setSaveState(false, "Finish a run to submit a score.");
          ball.stuckToPaddle = false;
        }
      }

      function clampPaddle() {
        if (paddle.x < 0) {
          paddle.x = 0;
        } else if (paddle.x + paddle.w > canvas.width) {
          paddle.x = canvas.width - paddle.w;
        }
      }

      function updatePaddle(dt) {
        const move = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
        if (move !== 0) {
          paddle.x += move * paddle.speed * dt;
          clampPaddle();
        }

        if (ball.stuckToPaddle) {
          ball.x = paddle.x + paddle.w / 2;
          ball.y = paddle.y - ball.r - 1;
        }
      }

      function ballHitsRect(rect) {
        const nearestX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.w));
        const nearestY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.h));
        const dx = ball.x - nearestX;
        const dy = ball.y - nearestY;
        return dx * dx + dy * dy <= ball.r * ball.r;
      }

      function reflectFromRect(rect) {
        const overlapLeft = ball.x + ball.r - rect.x;
        const overlapRight = rect.x + rect.w - (ball.x - ball.r);
        const overlapTop = ball.y + ball.r - rect.y;
        const overlapBottom = rect.y + rect.h - (ball.y - ball.r);

        const minX = Math.min(overlapLeft, overlapRight);
        const minY = Math.min(overlapTop, overlapBottom);

        if (minX < minY) {
          ball.vx *= -1;
        } else {
          ball.vy *= -1;
        }
      }

      function updateBall(dt) {
        if (ball.stuckToPaddle || state.gameOver || state.paused) {
          return;
        }

        ball.x += ball.vx * dt;
        ball.y += ball.vy * dt;

        if (ball.x - ball.r <= 0) {
          ball.x = ball.r;
          ball.vx = Math.abs(ball.vx);
        } else if (ball.x + ball.r >= canvas.width) {
          ball.x = canvas.width - ball.r;
          ball.vx = -Math.abs(ball.vx);
        }

        if (ball.y - ball.r <= 0) {
          ball.y = ball.r;
          ball.vy = Math.abs(ball.vy);
        }

        if (ball.y - ball.r > canvas.height) {
          loseLife();
          return;
        }

        if (
          ball.vy > 0 &&
          ball.y + ball.r >= paddle.y &&
          ball.y - ball.r <= paddle.y + paddle.h &&
          ball.x + ball.r >= paddle.x &&
          ball.x - ball.r <= paddle.x + paddle.w
        ) {
          ball.y = paddle.y - ball.r - 0.1;
          const hitOffset = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
          const maxAngle = Math.PI * 0.42;
          const speed = Math.min(Math.hypot(ball.vx, ball.vy) * 1.02, 780);
          ball.vx = speed * Math.sin(hitOffset * maxAngle);
          ball.vy = -Math.abs(speed * Math.cos(hitOffset * maxAngle));
        }

        for (let i = 0; i < bricks.length; i += 1) {
          const brick = bricks[i];
          if (!brick.alive) {
            continue;
          }
          if (ballHitsRect(brick)) {
            brick.alive = false;
            bricksLeft -= 1;
            state.score += brick.points;
            reflectFromRect(brick);
            updateHud();
            if (bricksLeft <= 0) {
              nextLevel();
            }
            break;
          }
        }
      }

      function update(dt) {
        if (state.gameOver || state.paused) {
          return;
        }
        updatePaddle(dt);
        updateBall(dt);
      }

      function drawBackdrop() {
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, "#17364b");
        grad.addColorStop(1, "#050b11");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawBricks() {
        for (let i = 0; i < bricks.length; i += 1) {
          const brick = bricks[i];
          if (!brick.alive) {
            continue;
          }
          const shade = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.h);
          shade.addColorStop(0, "#ffffff33");
          shade.addColorStop(0.25, brick.color);
          shade.addColorStop(1, "#00000022");
          ctx.fillStyle = shade;
          ctx.fillRect(brick.x, brick.y, brick.w, brick.h);

          ctx.strokeStyle = "#ffffff55";
          ctx.lineWidth = 1.2;
          ctx.strokeRect(brick.x + 0.6, brick.y + 0.6, brick.w - 1.2, brick.h - 1.2);
        }
      }

      function drawPaddle() {
        const grad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.h);
        grad.addColorStop(0, "#f7f7f7");
        grad.addColorStop(1, "#9da5b0");
        ctx.fillStyle = grad;
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
      }

      function drawBall() {
        const highlight = ctx.createRadialGradient(
          ball.x - 3,
          ball.y - 4,
          1,
          ball.x,
          ball.y,
          ball.r
        );
        highlight.addColorStop(0, "#fffef6");
        highlight.addColorStop(1, "#f4be67");
        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawOverlay() {
        if (state.paused || state.gameOver || ball.stuckToPaddle) {
          ctx.fillStyle = "rgba(0,0,0,0.45)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "#ffefc9";
          ctx.textAlign = "center";
          ctx.font = "bold 36px Impact, Haettenschweiler, sans-serif";

          if (state.gameOver) {
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 14);
            ctx.font = "bold 18px Trebuchet MS, sans-serif";
            ctx.fillText("Press ENTER or click New Game", canvas.width / 2, canvas.height / 2 + 24);
          } else if (state.paused) {
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2 - 10);
            ctx.font = "bold 18px Trebuchet MS, sans-serif";
            ctx.fillText("Press P to resume", canvas.width / 2, canvas.height / 2 + 24);
          } else if (ball.stuckToPaddle) {
            ctx.fillText(`LEVEL ${state.level}`, canvas.width / 2, canvas.height / 2 - 16);
            ctx.font = "bold 18px Trebuchet MS, sans-serif";
            if (getEnteredInitials()) {
              ctx.fillText("Press SPACE / tap to launch", canvas.width / 2, canvas.height / 2 + 24);
            } else {
              ctx.fillText("Enter initials to start", canvas.width / 2, canvas.height / 2 + 24);
            }
          }
        }
      }

      function drawTopLine() {
        ctx.fillStyle = "#ffefc6";
        ctx.font = "bold 16px Trebuchet MS, sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(`SCORE ${state.score}`, 16, 28);
        ctx.textAlign = "center";
        ctx.fillText(`LIVES ${state.lives}`, canvas.width / 2, 28);
        ctx.textAlign = "right";
        ctx.fillText(`LEVEL ${state.level}`, canvas.width - 16, 28);
      }

      function render() {
        drawBackdrop();
        drawBricks();
        drawPaddle();
        drawBall();
        drawTopLine();
        drawOverlay();
      }

      function updateHud() {
        uiScore.textContent = String(state.score);
        uiLives.textContent = String(state.lives);
        uiLevel.textContent = String(state.level);
      }

      function handlePointerMove(clientX) {
        const rect = canvas.getBoundingClientRect();
        const localX = ((clientX - rect.left) / rect.width) * canvas.width;
        paddle.x = localX - paddle.w / 2;
        clampPaddle();
        if (ball.stuckToPaddle) {
          ball.x = paddle.x + paddle.w / 2;
        }
      }

      function gameLoop(timestamp) {
        const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.02);
        lastFrameTime = timestamp;

        update(dt);
        render();

        requestAnimationFrame(gameLoop);
      }

      document.addEventListener("keydown", (event) => {
        if (event.code === "ArrowLeft" || event.code === "KeyA") {
          keys.left = true;
        } else if (event.code === "ArrowRight" || event.code === "KeyD") {
          keys.right = true;
        } else if (event.code === "Space") {
          event.preventDefault();
          launchBall();
        } else if (event.code === "KeyP" && !state.gameOver) {
          state.paused = !state.paused;
        } else if (event.code === "Enter" && state.gameOver) {
          startNewGame();
        }
      });

      document.addEventListener("keyup", (event) => {
        if (event.code === "ArrowLeft" || event.code === "KeyA") {
          keys.left = false;
        } else if (event.code === "ArrowRight" || event.code === "KeyD") {
          keys.right = false;
        }
      });

      canvas.addEventListener("mousemove", (event) => {
        handlePointerMove(event.clientX);
      });

      canvas.addEventListener("mousedown", () => {
        launchBall();
      });

      canvas.addEventListener(
        "touchstart",
        (event) => {
          const touch = event.touches[0];
          if (touch) {
            handlePointerMove(touch.clientX);
          }
          launchBall();
        },
        { passive: true }
      );

      canvas.addEventListener(
        "touchmove",
        (event) => {
          const touch = event.touches[0];
          if (touch) {
            handlePointerMove(touch.clientX);
            event.preventDefault();
          }
        },
        { passive: false }
      );

      initialsEl.addEventListener("input", () => {
        initialsEl.value = sanitizeInitials(initialsEl.value, "");
        if (!state.gameOver && ball.stuckToPaddle) {
          if (getEnteredInitials()) {
            setSaveState(false, "Press launch to start. Finish a run to submit a score.");
          } else {
            setSaveState(false, "Enter initials before starting.");
          }
        }
      });

      formEl.addEventListener("submit", (event) => {
        event.preventDefault();
        if (!state.canSubmitScore || state.hasSubmittedScore || state.score <= 0) {
          return;
        }

        const name = getEnteredInitials();
        if (!name) {
          setSaveState(true, "Enter initials before saving.");
          return;
        }
        leaderboard.push({
          name,
          score: state.score,
          level: state.level
        });
        leaderboard = leaderboard
          .sort((a, b) => b.score - a.score || b.level - a.level)
          .slice(0, 10);

        persistLeaderboard();
        renderLeaderboard();

        state.hasSubmittedScore = true;
        setSaveState(false, "Score saved to leaderboard.", true);
      });

      newGameBtn.addEventListener("click", () => {
        startNewGame();
      });

      renderLeaderboard();
      startNewGame();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
