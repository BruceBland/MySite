<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Classic Arcade Tetris</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800&amp;display=swap"
    rel="stylesheet"
  />
  <style>
    :root {
      --bg-1: #050507;
      --bg-2: #0c0f1a;
      --cabinet: #10141f;
      --panel: #0a0d16;
      --frame: #2b3244;
      --line: #19253d;
      --neon-blue: #37d5ff;
      --neon-red: #ff4f5e;
      --neon-yellow: #ffd84d;
      --text: #eff7ff;
      --muted: #9db0c9;
      --board-width: 135px;
      --sidebar-width: 205px;
      --leaderboard-width: 223px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Courier New", Courier, monospace;
      color: var(--text);
      background-image:
        linear-gradient(180deg, rgba(245, 247, 250, 0.72) 0%, rgba(238, 243, 255, 0.78) 100%),
        radial-gradient(1200px 700px at 12% -20%, rgba(219, 231, 255, 0.5) 0%, transparent 66%),
        radial-gradient(1100px 620px at 95% 12%, rgba(216, 245, 255, 0.46) 0%, transparent 64%),
        url("BackgroundImage.jpeg");
      background-size: auto, auto, auto, cover;
      background-position: center, center, center, center;
      background-repeat: no-repeat, no-repeat, no-repeat, no-repeat;
      background-attachment: scroll, scroll, scroll, fixed;
      overflow-x: hidden;
      padding: 4.8rem 1rem 1rem;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.03) 0,
        rgba(255, 255, 255, 0.03) 1px,
        transparent 1px,
        transparent 3px
      );
      opacity: 0.35;
    }

    .arcade-shell {
      width: fit-content;
      max-width: 96vw;
      background: linear-gradient(180deg, #111827, #090c12 62%);
      border: 8px solid #2f3442;
      border-radius: 18px;
      box-shadow:
        0 20px 60px rgba(0, 0, 0, 0.55),
        inset 0 0 0 2px #4f5a75,
        inset 0 0 40px rgba(55, 213, 255, 0.08);
      padding: 12px;
      position: relative;
      z-index: 1;
    }

    .bg-glow {
      position: fixed;
      width: 32rem;
      height: 32rem;
      border-radius: 999px;
      filter: blur(56px);
      pointer-events: none;
      z-index: 0;
    }

    .bg-glow-1 {
      top: -14rem;
      left: -10rem;
      background: rgba(16, 102, 255, 0.22);
    }

    .bg-glow-2 {
      bottom: -16rem;
      right: -12rem;
      background: rgba(0, 166, 166, 0.2);
    }

    .home-link-fixed {
      position: fixed;
      top: 14px;
      left: 14px;
      z-index: 10;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.64rem 1rem;
      border-radius: 999px;
      border: 1px solid rgba(15, 23, 42, 0.16);
      text-decoration: none;
      font-family: "Outfit", "SF Pro Text", "Helvetica Neue", "Segoe UI", sans-serif;
      font-weight: 600;
      font-size: 0.92rem;
      color: #0f172a;
      background: rgba(255, 255, 255, 0.86);
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.18);
      backdrop-filter: blur(10px);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .home-link-fixed:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.22);
    }

    .arcade-shell::after {
      content: "";
      position: absolute;
      inset: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      pointer-events: none;
    }

    .title {
      text-align: center;
      margin: 0 0 10px;
      padding: 10px;
      font-size: clamp(1.15rem, 3vw, 2rem);
      letter-spacing: 0.22rem;
      text-transform: uppercase;
      color: var(--neon-yellow);
      background: linear-gradient(180deg, #19223c, #101522);
      border: 2px solid #3f4d74;
      border-radius: 12px;
      text-shadow: 0 0 14px rgba(255, 216, 77, 0.55);
      box-shadow: inset 0 0 16px rgba(255, 255, 255, 0.05);
    }

    .layout {
      display: grid;
      gap: 12px;
      justify-content: center;
      align-items: start;
      grid-template-columns: max-content var(--sidebar-width) var(--leaderboard-width);
    }

    .playfield {
      background: linear-gradient(180deg, #0d1322, #06090f);
      border: 3px solid #3f4d74;
      border-radius: 14px;
      padding: 12px;
      box-shadow:
        inset 0 0 18px rgba(55, 213, 255, 0.1),
        0 10px 26px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      width: max-content;
      justify-self: center;
    }

    #gameCanvas {
      width: var(--board-width);
      height: auto;
      background: #050507;
      border: 3px solid #4f638f;
      border-radius: 8px;
      image-rendering: pixelated;
      box-shadow:
        0 0 18px rgba(55, 213, 255, 0.22),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
    }

    .stats {
      width: var(--board-width);
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .stat {
      background: var(--panel);
      border: 1px solid #36517e;
      border-radius: 8px;
      padding: 6px 4px;
      text-align: center;
      box-shadow: inset 0 0 10px rgba(55, 213, 255, 0.1);
    }

    .stat-label {
      color: var(--muted);
      font-size: 0.62rem;
      text-transform: uppercase;
      letter-spacing: 0.12rem;
      display: block;
      margin-bottom: 2px;
    }

    .stat-value {
      font-size: 0.9rem;
      color: #dff8ff;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(55, 213, 255, 0.45);
    }

    .hint {
      width: var(--board-width);
      margin: 0;
      padding: 8px 8px;
      font-size: 0.62rem;
      line-height: 1.4;
      letter-spacing: 0.04rem;
      color: #d5e4f5;
      background: #0a0f1b;
      border: 1px solid #2f4a7a;
      border-radius: 8px;
      text-transform: uppercase;
    }

    .sidebar-panel {
      background: linear-gradient(180deg, #0d1322, #06090f);
      border: 3px solid #3f4d74;
      border-radius: 14px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: var(--sidebar-width);
      justify-self: center;
      box-shadow:
        inset 0 0 18px rgba(255, 79, 94, 0.08),
        0 10px 26px rgba(0, 0, 0, 0.38);
    }

    .panel {
      background: #0a0f1b;
      border: 1px solid #305088;
      border-radius: 10px;
      padding: 8px;
    }

    .panel-title {
      margin: 0 0 6px;
      font-size: 0.76rem;
      text-transform: uppercase;
      letter-spacing: 0.15rem;
      color: #cde2ff;
    }

    .bb-logo {
      border: 1px solid #305088;
      border-radius: 10px;
      padding: 9px 8px;
      text-align: center;
      background: linear-gradient(160deg, #13243a 0%, #0a1320 100%);
      box-shadow: inset 0 0 0 1px rgba(55, 213, 255, 0.16);
    }

    .bb-logo .brand {
      display: block;
      color: #e5f6ff;
      font-size: 0.92rem;
      font-weight: 800;
      letter-spacing: 0.12rem;
      line-height: 1;
    }

    .bb-logo .sub {
      display: block;
      margin-top: 5px;
      color: #9dd8f4;
      font-size: 0.56rem;
      letter-spacing: 0.08rem;
      text-transform: uppercase;
    }

    .leader-now {
      border-color: #5e4460;
      box-shadow: inset 0 0 14px rgba(255, 79, 94, 0.15);
    }

    #leaderName {
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--neon-red);
      text-shadow: 0 0 12px rgba(255, 79, 94, 0.55);
      letter-spacing: 0.1rem;
      text-transform: uppercase;
    }

    #leaderScore {
      margin-top: 4px;
      color: #ffe4e7;
      font-size: 0.85rem;
      letter-spacing: 0.04rem;
    }

    #nextCanvas {
      width: 96px;
      height: 96px;
      display: block;
      margin: 0 auto;
      background: #06090f;
      border: 2px solid #3f618f;
      border-radius: 8px;
      image-rendering: pixelated;
    }

    .name-wrap {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .name-wrap label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.12rem;
      color: var(--muted);
    }

    #playerName {
      width: 100%;
      border: 1px solid #3f638f;
      border-radius: 7px;
      background: #04070d;
      color: #e9f4ff;
      padding: 7px 8px;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.08rem;
      outline: none;
    }

    #playerName:focus {
      box-shadow: 0 0 0 2px rgba(55, 213, 255, 0.28);
      border-color: var(--neon-blue);
    }

    #leaderboard {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .leader-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      color: #d6e9ff;
      padding: 6px 7px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
      border: 1px solid rgba(78, 108, 150, 0.45);
    }

    .leader-row.rank-1 {
      border-color: rgba(255, 216, 77, 0.75);
      color: #ffe793;
      box-shadow: inset 0 0 10px rgba(255, 216, 77, 0.14);
    }

    .leader-name {
      max-width: 65%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      letter-spacing: 0.05rem;
    }

    .leader-score {
      color: #c7f2ff;
      font-weight: 700;
      margin-left: 10px;
    }

    .controls {
      display: flex;
      gap: 8px;
    }

    .sidebar-main .controls {
      margin-top: auto;
    }

    .sidebar-leaderboard #leaderboard {
      min-height: 206px;
    }

    button,
    .control-link {
      flex: 1;
      border: 1px solid #4f618c;
      border-radius: 8px;
      background: linear-gradient(180deg, #1a243a, #0f1525);
      color: #e5f3ff;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.08rem;
      padding: 8px 8px;
      cursor: pointer;
      transition: transform 100ms ease, box-shadow 100ms ease;
      text-decoration: none;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover,
    .control-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 10px rgba(55, 213, 255, 0.35);
    }

    .status {
      margin: 10px 0 0;
      border: 1px solid #445986;
      border-radius: 8px;
      background: #0b101c;
      color: #ecf6ff;
      padding: 8px;
      text-align: center;
      font-size: 0.7rem;
      letter-spacing: 0.05rem;
      text-transform: uppercase;
      min-height: 38px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .status.alert {
      color: #ffe3e6;
      border-color: rgba(255, 79, 94, 0.7);
      box-shadow: inset 0 0 12px rgba(255, 79, 94, 0.14);
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
        gap: 10px;
        justify-items: center;
      }

      .playfield,
      .sidebar-panel {
        width: min(100%, 320px);
      }

      .arcade-shell {
        width: min(98vw, 420px);
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="bg-glow bg-glow-1" aria-hidden="true"></div>
  <div class="bg-glow bg-glow-2" aria-hidden="true"></div>
  <a class="home-link-fixed" href="games.html">Home</a>
  <main class="arcade-shell">
    <h1 class="title">Classic Arcade Tetris</h1>

    <div class="layout">
      <section class="playfield">
        <canvas id="gameCanvas" width="150" height="300" aria-label="Tetris game board"></canvas>

        <div class="stats">
          <div class="stat">
            <span class="stat-label">Score</span>
            <span id="score" class="stat-value">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Lines</span>
            <span id="lines" class="stat-value">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Level</span>
            <span id="level" class="stat-value">1</span>
          </div>
        </div>

        <p class="hint">Arrows: move | Up: rotate | Space: start/hard drop | P: pause</p>
      </section>

      <aside class="sidebar-main sidebar-panel">
        <section class="bb-logo" aria-label="BB Games logo">
          <span class="brand">BB GAMES</span>
          <span class="sub">Tetris Arcade</span>
        </section>

        <section class="panel">
          <h2 class="panel-title">Next Piece</h2>
          <canvas id="nextCanvas" width="120" height="120" aria-label="Next tetris piece preview"></canvas>
        </section>

        <section class="panel name-wrap">
          <label for="playerName">Player Tag</label>
          <input id="playerName" maxlength="8" value="YOU" />
        </section>

        <div class="controls">
          <button id="restartBtn" type="button">New Game</button>
          <button id="pauseBtn" type="button">Pause</button>
        </div>
      </aside>

      <aside class="sidebar-leaderboard sidebar-panel">
        <section class="panel leader-now">
          <h2 class="panel-title">Current Leader</h2>
          <div id="leaderName">NO LEADER</div>
          <div id="leaderScore">0 PTS</div>
        </section>

        <section class="panel">
          <h2 class="panel-title">Top 5 Leaderboard</h2>
          <ol id="leaderboard"></ol>
        </section>
      </aside>
    </div>

    <p id="status" class="status">Drop in and chase the high score.</p>
  </main>

  <script>
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 15;
    const NEXT_BLOCK_SIZE = 24;
    const LEADERBOARD_KEY = "classic_tetris_top5_v1";
    const LINE_SCORES = [0, 40, 100, 300, 1200];

    const COLORS = {
      I: "#00f0f0",
      J: "#0046ff",
      L: "#ff9f1c",
      O: "#f7e733",
      S: "#00df6a",
      T: "#ac4cff",
      Z: "#ff3b3b"
    };

    const SHAPES = {
      I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      J: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      L: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ],
      O: [
        [1, 1],
        [1, 1]
      ],
      S: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      T: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      Z: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ]
    };

    const PIECES = Object.keys(SHAPES);

    const gameCanvas = document.getElementById("gameCanvas");
    const gameCtx = gameCanvas.getContext("2d");
    gameCtx.scale(BLOCK_SIZE, BLOCK_SIZE);

    const nextCanvas = document.getElementById("nextCanvas");
    const nextCtx = nextCanvas.getContext("2d");
    nextCtx.scale(NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);

    const scoreEl = document.getElementById("score");
    const linesEl = document.getElementById("lines");
    const levelEl = document.getElementById("level");
    const statusEl = document.getElementById("status");
    const leaderboardEl = document.getElementById("leaderboard");
    const leaderNameEl = document.getElementById("leaderName");
    const leaderScoreEl = document.getElementById("leaderScore");
    const playerNameEl = document.getElementById("playerName");
    const restartBtn = document.getElementById("restartBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    let arena = createMatrix(COLS, ROWS);
    let player = null;
    let nextPieceType = null;
    let bag = [];

    let score = 0;
    let lines = 0;
    let level = 0;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let paused = false;
    let gameOver = false;
    let awaitingStart = true;

    let leaderboard = loadLeaderboard();

    function createMatrix(width, height) {
      const matrix = [];
      for (let y = 0; y < height; y += 1) {
        matrix.push(new Array(width).fill(0));
      }
      return matrix;
    }

    function cloneMatrix(matrix) {
      return matrix.map((row) => row.slice());
    }

    function shuffle(array) {
      const copy = array.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function pullFromBag() {
      if (bag.length === 0) {
        bag = shuffle(PIECES);
      }
      return bag.pop();
    }

    function createPiece(type) {
      return {
        type,
        matrix: cloneMatrix(SHAPES[type]),
        x: 0,
        y: 0
      };
    }

    function collide(board, activePiece) {
      for (let y = 0; y < activePiece.matrix.length; y += 1) {
        for (let x = 0; x < activePiece.matrix[y].length; x += 1) {
          if (activePiece.matrix[y][x] === 0) {
            continue;
          }

          const posX = x + activePiece.x;
          const posY = y + activePiece.y;

          if (posX < 0 || posX >= COLS || posY >= ROWS) {
            return true;
          }

          if (posY >= 0 && board[posY][posX] !== 0) {
            return true;
          }
        }
      }

      return false;
    }

    function merge(board, activePiece) {
      activePiece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            const boardY = y + activePiece.y;
            const boardX = x + activePiece.x;
            if (boardY >= 0) {
              board[boardY][boardX] = activePiece.type;
            }
          }
        });
      });
    }

    function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; y += 1) {
        for (let x = 0; x < y; x += 1) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }

      if (dir > 0) {
        matrix.forEach((row) => row.reverse());
      } else {
        matrix.reverse();
      }
    }

    function rotatePlayer(dir) {
      const originalX = player.x;
      let offset = 1;

      rotate(player.matrix, dir);

      while (collide(arena, player)) {
        player.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));

        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.x = originalX;
          return;
        }
      }
    }

    function clearLines() {
      let cleared = 0;

      outer: for (let y = ROWS - 1; y >= 0; y -= 1) {
        for (let x = 0; x < COLS; x += 1) {
          if (arena[y][x] === 0) {
            continue outer;
          }
        }

        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        y += 1;
        cleared += 1;
      }

      if (cleared > 0) {
        lines += cleared;
        score += LINE_SCORES[cleared] * (level + 1);
        level = Math.floor(lines / 10);
        dropInterval = Math.max(100, 1000 - level * 80);
        updateStats();
      }
    }

    function dropPiece() {
      player.y += 1;

      if (collide(arena, player)) {
        player.y -= 1;
        merge(arena, player);
        clearLines();
        spawnPiece();
      }

      dropCounter = 0;
    }

    function hardDrop() {
      while (!collide(arena, player)) {
        player.y += 1;
      }

      player.y -= 1;
      merge(arena, player);
      clearLines();
      spawnPiece();
      dropCounter = 0;
    }

    function movePlayer(dir) {
      player.x += dir;
      if (collide(arena, player)) {
        player.x -= dir;
      }
    }

    function spawnPiece() {
      const type = nextPieceType || pullFromBag();
      nextPieceType = pullFromBag();

      player = createPiece(type);
      player.x = Math.floor(COLS / 2 - player.matrix[0].length / 2);
      player.y = 0;

      drawNextPiece();

      if (collide(arena, player)) {
        finishGame();
      }
    }

    function resetGame() {
      arena = createMatrix(COLS, ROWS);
      bag = [];
      nextPieceType = pullFromBag();

      score = 0;
      lines = 0;
      level = 0;
      dropCounter = 0;
      dropInterval = 1000;
      paused = false;
      gameOver = false;
      awaitingStart = true;

      pauseBtn.textContent = "Pause";
      updateStats();
      setStatus("Press Space to start.", false);
      spawnPiece();
    }

    function finishGame() {
      gameOver = true;
      paused = false;
      awaitingStart = false;
      pauseBtn.textContent = "Pause";
      maybeAddScore();
      setStatus("Game over. Press Enter or New Game, then Space to start.", true);
    }

    function startGame() {
      if (!awaitingStart || gameOver) {
        return;
      }

      awaitingStart = false;
      paused = false;
      dropCounter = 0;
      setStatus("Game on. Good luck.", false);
    }

    function updateStats() {
      scoreEl.textContent = score.toLocaleString();
      linesEl.textContent = lines.toString();
      levelEl.textContent = (level + 1).toString();
    }

    function drawBlock(ctx, x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 1, 1);

      ctx.fillStyle = "rgba(255, 255, 255, 0.24)";
      ctx.fillRect(x + 0.06, y + 0.06, 0.88, 0.16);

      ctx.fillStyle = "rgba(0, 0, 0, 0.26)";
      ctx.fillRect(x + 0.06, y + 0.76, 0.88, 0.18);

      ctx.strokeStyle = "rgba(0, 0, 0, 0.35)";
      ctx.lineWidth = 0.06;
      ctx.strokeRect(x + 0.03, y + 0.03, 0.94, 0.94);
    }

    function drawMatrix(ctx, matrix, offset, forcedType) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value === 0) {
            return;
          }

          const type = typeof value === "string" ? value : forcedType;
          drawBlock(ctx, x + offset.x, y + offset.y, COLORS[type]);
        });
      });
    }

    function drawGrid() {
      gameCtx.strokeStyle = "rgba(77, 114, 166, 0.2)";
      gameCtx.lineWidth = 0.03;

      for (let x = 0; x <= COLS; x += 1) {
        gameCtx.beginPath();
        gameCtx.moveTo(x, 0);
        gameCtx.lineTo(x, ROWS);
        gameCtx.stroke();
      }

      for (let y = 0; y <= ROWS; y += 1) {
        gameCtx.beginPath();
        gameCtx.moveTo(0, y);
        gameCtx.lineTo(COLS, y);
        gameCtx.stroke();
      }
    }

    function drawOverlay(mainText, subText) {
      gameCtx.fillStyle = "rgba(0, 0, 0, 0.68)";
      gameCtx.fillRect(0, 0, COLS, ROWS);

      gameCtx.textAlign = "center";
      gameCtx.fillStyle = "#ffffff";
      gameCtx.font = '1px "Courier New", monospace';
      gameCtx.fillText(mainText, COLS / 2, ROWS / 2 - 0.4);

      if (subText) {
        gameCtx.fillStyle = "#d4e9ff";
        gameCtx.font = '0.48px "Courier New", monospace';
        gameCtx.fillText(subText, COLS / 2, ROWS / 2 + 0.6);
      }
    }

    function drawNextPiece() {
      nextCtx.fillStyle = "#06090f";
      nextCtx.fillRect(0, 0, 5, 5);

      const matrix = SHAPES[nextPieceType];
      if (!matrix) {
        return;
      }

      const offset = {
        x: (5 - matrix[0].length) / 2,
        y: (5 - matrix.length) / 2
      };

      drawMatrix(nextCtx, matrix, offset, nextPieceType);
    }

    function draw() {
      gameCtx.fillStyle = "#050507";
      gameCtx.fillRect(0, 0, COLS, ROWS);

      drawMatrix(gameCtx, arena, { x: 0, y: 0 });
      if (player) {
        drawMatrix(gameCtx, player.matrix, { x: player.x, y: player.y }, player.type);
      }
      drawGrid();

      if (awaitingStart && !gameOver) {
        drawOverlay("Ready?", "Press Space to start");
      }

      if (paused && !gameOver) {
        drawOverlay("Paused", "Press P to resume");
      }

      if (gameOver) {
        drawOverlay("Game Over", "Press Enter to restart");
      }
    }

    function update(time = 0) {
      const deltaTime = time - lastTime;
      lastTime = time;

      if (!awaitingStart && !paused && !gameOver) {
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          dropPiece();
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    function sanitizeName(value) {
      return String(value || "")
        .toUpperCase()
        .replace(/[^A-Z0-9]/g, "")
        .slice(0, 8);
    }

    function loadLeaderboard() {
      const fallback = [];

      try {
        const raw = localStorage.getItem(LEADERBOARD_KEY);
        if (!raw) {
          return fallback;
        }

        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
          return fallback;
        }

        return parsed
          .map((entry) => ({
            name: sanitizeName(entry.name || ""),
            score: Number.isFinite(entry.score) ? Math.max(0, Math.floor(entry.score)) : 0
          }))
          .filter((entry) => entry.name.length > 0)
          .sort((a, b) => b.score - a.score)
          .slice(0, 5);
      } catch (error) {
        return fallback;
      }
    }

    function saveLeaderboard() {
      localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard.slice(0, 5)));
    }

    function renderLeaderboard() {
      leaderboardEl.innerHTML = "";

      const entries = leaderboard.slice(0, 5);

      for (let i = 0; i < 5; i += 1) {
        const entry = entries[i] || { name: "---", score: 0 };

        const row = document.createElement("li");
        row.className = `leader-row rank-${i + 1}`;

        const name = document.createElement("span");
        name.className = "leader-name";
        name.textContent = `${i + 1}. ${entry.name}`;

        const points = document.createElement("span");
        points.className = "leader-score";
        points.textContent = `${entry.score.toLocaleString()} PTS`;

        row.appendChild(name);
        row.appendChild(points);
        leaderboardEl.appendChild(row);
      }

      if (entries.length > 0) {
        leaderNameEl.textContent = entries[0].name;
        leaderScoreEl.textContent = `${entries[0].score.toLocaleString()} PTS`;
      } else {
        leaderNameEl.textContent = "NO LEADER";
        leaderScoreEl.textContent = "0 PTS";
      }
    }

    function maybeAddScore() {
      if (score <= 0) {
        return;
      }

      const qualifies = leaderboard.length < 5 || score > leaderboard[leaderboard.length - 1].score;
      if (!qualifies) {
        return;
      }

      const fallback = sanitizeName(playerNameEl.value) || "YOU";
      const response = window.prompt(`New Top 5 Score: ${score.toLocaleString()}\nEnter your tag (max 8 chars):`, fallback);
      const finalName = sanitizeName(response || fallback) || "YOU";

      leaderboard.push({ name: finalName, score });
      leaderboard.sort((a, b) => b.score - a.score);
      leaderboard = leaderboard.slice(0, 5);

      saveLeaderboard();
      renderLeaderboard();
      setStatus(`${finalName} entered the leaderboard with ${score.toLocaleString()} points.`, false);
    }

    function setStatus(message, isAlert) {
      statusEl.textContent = message;
      statusEl.classList.toggle("alert", Boolean(isAlert));
    }

    function togglePause() {
      if (gameOver || awaitingStart) {
        return;
      }

      paused = !paused;
      pauseBtn.textContent = paused ? "Resume" : "Pause";
      setStatus(paused ? "Game paused." : "Back in play.", false);
    }

    document.addEventListener("keydown", (event) => {
      const isSpaceKey = event.key === " " || event.code === "Space" || event.key === "Spacebar";
      const keysToCapture = ["ArrowLeft", "ArrowRight", "ArrowDown", "ArrowUp", "p", "P", "Enter"];
      if (isSpaceKey || keysToCapture.includes(event.key)) {
        event.preventDefault();
      }

      if (event.key === "Enter" && gameOver) {
        resetGame();
        return;
      }

      if (isSpaceKey && awaitingStart && !gameOver) {
        startGame();
        return;
      }

      if (event.key === "p" || event.key === "P") {
        togglePause();
        return;
      }

      if (awaitingStart || paused || gameOver) {
        return;
      }

      if (event.key === "ArrowLeft") {
        movePlayer(-1);
      } else if (event.key === "ArrowRight") {
        movePlayer(1);
      } else if (event.key === "ArrowDown") {
        dropPiece();
      } else if (event.key === "ArrowUp") {
        rotatePlayer(1);
      } else if (isSpaceKey) {
        hardDrop();
      }
    });

    restartBtn.addEventListener("click", resetGame);
    pauseBtn.addEventListener("click", togglePause);

    playerNameEl.addEventListener("input", () => {
      const cleaned = sanitizeName(playerNameEl.value);
      if (playerNameEl.value !== cleaned) {
        playerNameEl.value = cleaned;
      }
    });

    renderLeaderboard();
    updateStats();
    drawNextPiece();
    resetGame();
    update();
  </script>
</body>
</html>
